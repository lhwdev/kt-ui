package com.lhwdev.ktui.compilerPlugin

import org.jetbrains.kotlin.com.intellij.openapi.project.Project
import org.jetbrains.kotlin.com.intellij.psi.PsiElement
import org.jetbrains.kotlin.container.StorageComponentContainer
import org.jetbrains.kotlin.container.useInstance
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.ConstructorDescriptor
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.descriptors.ModuleDescriptor
import org.jetbrains.kotlin.descriptors.PropertyDescriptor
import org.jetbrains.kotlin.descriptors.TypeAliasDescriptor
import org.jetbrains.kotlin.descriptors.ValueParameterDescriptor
import org.jetbrains.kotlin.descriptors.VariableDescriptor
import org.jetbrains.kotlin.descriptors.annotations.KotlinTarget
import org.jetbrains.kotlin.descriptors.impl.LocalVariableDescriptor
import org.jetbrains.kotlin.diagnostics.Errors
import org.jetbrains.kotlin.diagnostics.reportFromPlugin
import org.jetbrains.kotlin.extensions.StorageComponentContainerContributor
import org.jetbrains.kotlin.js.resolve.diagnostics.findPsi
import org.jetbrains.kotlin.load.java.descriptors.JavaMethodDescriptor
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.psi.KtAnnotatedExpression
import org.jetbrains.kotlin.psi.KtAnnotationEntry
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtClass
import org.jetbrains.kotlin.psi.KtDeclaration
import org.jetbrains.kotlin.psi.KtElement
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.psi.KtFunction
import org.jetbrains.kotlin.psi.KtLambdaExpression
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.psi.KtObjectLiteralExpression
import org.jetbrains.kotlin.psi.KtParameter
import org.jetbrains.kotlin.psi.KtProperty
import org.jetbrains.kotlin.psi.KtTreeVisitorVoid
import org.jetbrains.kotlin.descriptors.PropertyGetterDescriptor
import org.jetbrains.kotlin.descriptors.impl.AnonymousFunctionDescriptor
import org.jetbrains.kotlin.resolve.AdditionalAnnotationChecker
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.BindingTrace
import org.jetbrains.kotlin.platform.TargetPlatform
import org.jetbrains.kotlin.platform.jvm.isJvm
import org.jetbrains.kotlin.psi.KtFunctionLiteral
import org.jetbrains.kotlin.psi.KtLambdaArgument
import org.jetbrains.kotlin.psi.KtPropertyAccessor
import org.jetbrains.kotlin.psi.KtSimpleNameExpression
import org.jetbrains.kotlin.resolve.calls.callUtil.getResolvedCall
import org.jetbrains.kotlin.resolve.calls.checkers.AdditionalTypeChecker
import org.jetbrains.kotlin.resolve.calls.checkers.CallChecker
import org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext
import org.jetbrains.kotlin.resolve.calls.context.ResolutionContext
import org.jetbrains.kotlin.resolve.calls.model.ResolvedCall
import org.jetbrains.kotlin.resolve.calls.model.VariableAsFunctionResolvedCall
import org.jetbrains.kotlin.resolve.checkers.DeclarationChecker
import org.jetbrains.kotlin.resolve.checkers.DeclarationCheckerContext
import org.jetbrains.kotlin.resolve.inline.InlineUtil.isInlinedArgument
import org.jetbrains.kotlin.types.KotlinType
import org.jetbrains.kotlin.types.TypeUtils
import org.jetbrains.kotlin.types.lowerIfFlexible
import org.jetbrains.kotlin.types.typeUtil.builtIns
import org.jetbrains.kotlin.types.upperIfFlexible
import org.jetbrains.kotlin.util.OperatorNameConventions
import org.jetbrains.kotlin.utils.addToStdlib.cast

open class WidgetAnnotationChecker : CallChecker, DeclarationChecker,
	AdditionalTypeChecker, AdditionalAnnotationChecker, StorageComponentContainerContributor {
	
	companion object {
		fun get(project: Project): WidgetAnnotationChecker {
			return StorageComponentContainerContributor.getInstances(project).single {
				it is WidgetAnnotationChecker
			} as WidgetAnnotationChecker
		}
	}
	
	enum class Widgetability { notWidget, inferred, marked }
	
	fun shouldInvokeAsTag(trace: BindingTrace, resolvedCall: ResolvedCall<*>): Boolean {
		if (resolvedCall is VariableAsFunctionResolvedCall) {
			if (resolvedCall.variableCall.candidateDescriptor.type.isWidgetKind())
				return true
			if (resolvedCall.functionCall.resultingDescriptor.isWidgetKind()) return true
			return false
		}
		val candidateDescriptor = resolvedCall.candidateDescriptor
		if (candidateDescriptor is FunctionDescriptor) {
			if (candidateDescriptor.isOperator &&
				candidateDescriptor.name == OperatorNameConventions.INVOKE) {
				if (resolvedCall.dispatchReceiver?.type?.isWidgetKind() == true) {
					return true
				}
			}
		}
		if (candidateDescriptor is FunctionDescriptor) {
			return when (analyze(trace, candidateDescriptor)) {
				Widgetability.notWidget -> false
				Widgetability.inferred -> true
				Widgetability.marked -> true
			}
		}
		if (candidateDescriptor is ValueParameterDescriptor) {
			return candidateDescriptor.type.isWidgetKind()
		}
		if (candidateDescriptor is LocalVariableDescriptor) {
			return candidateDescriptor.type.isWidgetKind()
		}
		if (candidateDescriptor is PropertyDescriptor) {
			return candidateDescriptor.isWidgetKind()
		}
		return candidateDescriptor.isWidgetKind()
	}
	
	fun analyze(trace: BindingTrace, descriptor: FunctionDescriptor): Widgetability {
		val unwrappedDescriptor = when (descriptor) {
//			is WidgetFunctionDescriptor -> descriptor.underlyingDescriptor // TODO
			else -> descriptor
		}
		val psi = unwrappedDescriptor.findPsi() as? KtElement
		psi?.let { element -> trace.bindingContext.get(UiWritableSlices.WIDGET_ANALYSIS, element)?.let { return it } }
		if (unwrappedDescriptor.name == Name.identifier("compose") &&
			unwrappedDescriptor.containingDeclaration is ClassDescriptor &&
			isWidgetComponent(unwrappedDescriptor.containingDeclaration)
		) return Widgetability.marked
		var composability = Widgetability.notWidget
		if (trace.bindingContext.get(
				INFERRED_COMPOSABLE_DESCRIPTOR,
				unwrappedDescriptor
			) ?: false) {
			composability = Widgetability.marked
		} else {
			when (unwrappedDescriptor) {
				is VariableDescriptor ->
					if (unwrappedDescriptor.hasComposableAnnotation() ||
						unwrappedDescriptor.type.hasComposableAnnotation()
					)
						composability =
							Widgetability.marked
				is ConstructorDescriptor ->
					if (unwrappedDescriptor.hasComposableAnnotation()) composability =
						Widgetability.marked
				is JavaMethodDescriptor ->
					if (unwrappedDescriptor.hasComposableAnnotation()) composability =
						Widgetability.marked
				is AnonymousFunctionDescriptor -> {
					if (unwrappedDescriptor.hasComposableAnnotation()) composability =
						Widgetability.marked
					if (psi is KtFunctionLiteral && psi.isEmitInline(trace.bindingContext)) {
						composability = Widgetability.marked
					}
				}
				is PropertyGetterDescriptor ->
					if (unwrappedDescriptor.correspondingProperty.hasComposableAnnotation())
						composability = Widgetability.marked
				else -> if (unwrappedDescriptor.hasComposableAnnotation()) composability =
					Widgetability.marked
			}
		}
		(unwrappedDescriptor.findPsi() as? KtElement)?.let {
			element -> composability = analyzeFunctionContents(trace, element, composability)
		}
		psi?.let { trace.record(COMPOSABLE_ANALYSIS, it, composability) }
		return composability
	}
	
	private fun analyzeFunctionContents(
		trace: BindingTrace,
		element: KtElement,
		signatureWidgetability: Widgetability
	): Widgetability {
		var composability = signatureWidgetability
		var localFcs = false
		var isInlineLambda = false
		element.accept(object : KtTreeVisitorVoid() {
			override fun visitNamedFunction(function: KtNamedFunction) {
				if (function == element) {
					super.visitNamedFunction(function)
				}
			}
			
			override fun visitPropertyAccessor(accessor: KtPropertyAccessor) {
				// this is basically a function, so unless it is the function we are analyzing, we
				// stop here
				if (accessor == element) {
					super.visitPropertyAccessor(accessor)
				}
			}
			
			override fun visitClass(klass: KtClass) {
				// never traverse a class
			}
			
			override fun visitLambdaExpression(lambdaExpression: KtLambdaExpression) {
				val isInlineable = isInlinedArgument(
					lambdaExpression.functionLiteral,
					trace.bindingContext,
					true
				)
				if (isInlineable && lambdaExpression == element) isInlineLambda = true
				if (isInlineable || lambdaExpression == element)
					super.visitLambdaExpression(lambdaExpression)
			}
			
			override fun visitSimpleNameExpression(expression: KtSimpleNameExpression) {
				val resolvedCall = expression.getResolvedCall(trace.bindingContext)
				if (resolvedCall?.candidateDescriptor is PropertyDescriptor) {
					checkResolvedCall(
						resolvedCall,
						trace.get(FCS_RESOLVEDCALL_COMPOSABLE, expression),
						expression
					)
				}
				super.visitSimpleNameExpression(expression)
			}
			
			override fun visitCallExpression(expression: KtCallExpression) {
				val resolvedCall = expression.getResolvedCall(trace.bindingContext)
				checkResolvedCall(
					resolvedCall,
					trace.get(FCS_RESOLVEDCALL_COMPOSABLE, expression),
					expression.calleeExpression ?: expression
				)
				super.visitCallExpression(expression)
			}
			
			private fun checkResolvedCall(
				resolvedCall: ResolvedCall<*>?,
				isCallComposable: Boolean?,
				reportElement: KtExpression
			) {
				when (resolvedCall?.candidateDescriptor) {
					is ComposableEmitDescriptor,
					is ComposablePropertyDescriptor,
					is ComposableFunctionDescriptor -> {
						localFcs = true
						if (!isInlineLambda && composability != Widgetability.marked) {
							// Report error on composable element to make it obvious which invocation is offensive
							trace.reportFromPlugin(
								ComposeErrors.COMPOSABLE_INVOCATION_IN_NON_COMPOSABLE
									.on(reportElement),
								ComposeDefaultErrorMessages
							)
						}
					}
				}
				// Can be null in cases where the call isn't resolvable (eg. due to a bug/typo in the user's code)
				if (isCallComposable == true) {
					localFcs = true
					if (!isInlineLambda && composability != Widgetability.marked) {
						// Report error on composable element to make it obvious which invocation is offensive
						trace.reportFromPlugin(
							ComposeErrors.COMPOSABLE_INVOCATION_IN_NON_COMPOSABLE
								.on(reportElement),
							ComposeDefaultErrorMessages
						)
					}
				}
			}
		}, null)
		if (
			localFcs &&
			!isInlineLambda && composability != Widgetability.marked
		) {
			val reportElement = when (element) {
				is KtNamedFunction -> element.nameIdentifier ?: element
				else -> element
			}
			if (localFcs) {
				trace.reportFromPlugin(
					ComposeErrors.COMPOSABLE_INVOCATION_IN_NON_COMPOSABLE.on(reportElement),
					ComposeDefaultErrorMessages
				)
			}
		}
		if (localFcs && composability == Widgetability.notWidget)
			composability =
				Widgetability.inferred
		return composability
	}
	
	/**
	 * Analyze a KtElement
	 *  - Determine if it is @Widget or @WidgetUtil (eg. the element or inferred type has an @Widget annotation)
	 *  - Update the binding context to cache analysis results
	 *  - Report errors (eg. invocations of an widgetKind etc)
	 *  - Return true if element is widgetKind, else false
	 */
	fun analyze(trace: BindingTrace, element: KtElement, type: KotlinType?): Widgetability {
		trace.bindingContext.get(COMPOSABLE_ANALYSIS, element)?.let { return it }
		
		var composability =
			Widgetability.notWidget
		
		if (element is KtClass) {
			val descriptor = trace.bindingContext.get(BindingContext.CLASS, element)
				?: error("Element class context not found")
			val annotationEntry = element.annotationEntries.singleOrNull {
				trace.bindingContext.get(BindingContext.ANNOTATION, it)?.isComposableAnnotation
					?: false
			}
			if (annotationEntry != null && !ComposeUtils.isComposeComponent(descriptor)) {
				trace.report(
					Errors.WRONG_ANNOTATION_TARGET.on(
						annotationEntry,
						"class which does not extend androidx.compose.Component"
					)
				)
			}
			if (ComposeUtils.isComposeComponent(descriptor)) {
				composability += Widgetability.marked
			}
		}
		if (element is KtParameter) {
			val composableAnnotation = element
				.typeReference
				?.annotationEntries
				?.mapNotNull { trace.bindingContext.get(BindingContext.ANNOTATION, it) }
				?.singleOrNull { it.isComposableAnnotation }
			
			if (composableAnnotation != null) {
				composability += Widgetability.marked
			}
		}
		if (element is KtParameter) {
			val composableAnnotation = element
				.typeReference
				?.annotationEntries
				?.mapNotNull { trace.bindingContext.get(BindingContext.ANNOTATION, it) }
				?.singleOrNull { it.isComposableAnnotation }
			
			if (composableAnnotation != null) {
				composability += Widgetability.marked
			}
		}
		
		// if (candidateDescriptor.type.arguments.size != 1 || !candidateDescriptor.type.arguments[0].type.isUnit()) return false
		if (
			type != null &&
			type !== TypeUtils.NO_EXPECTED_TYPE &&
			type.hasComposableAnnotation()
		) {
			composability += Widgetability.marked
		}
		val parent = element.parent
		val annotations = when {
			element is KtNamedFunction -> element.annotationEntries
			parent is KtAnnotatedExpression -> parent.annotationEntries
			element is KtProperty -> element.annotationEntries
			element is KtParameter -> element.typeReference?.annotationEntries ?: emptyList()
			else -> emptyList()
		}
		
		for (entry in annotations) {
			val descriptor = trace.bindingContext.get(BindingContext.ANNOTATION, entry) ?: continue
			if (descriptor.isComposableAnnotation) {
				composability += Widgetability.marked
			}
		}
		
		if (element is KtLambdaExpression || element is KtFunction) {
			val associatedCall = parent?.parent as? KtCallExpression
			
			if (associatedCall != null && parent is KtLambdaArgument) {
				val resolvedCall = associatedCall.getResolvedCall(trace.bindingContext)
				if (resolvedCall?.candidateDescriptor is ComposableEmitDescriptor) {
					composability += Widgetability.marked
				}
			}
			
			composability = analyzeFunctionContents(trace, element, composability)
		}
		
		trace.record(COMPOSABLE_ANALYSIS, element, composability)
		return composability
	}
	
	override fun registerModuleComponents(
		container: StorageComponentContainer,
		platform: TargetPlatform,
		moduleDescriptor: ModuleDescriptor
	) {
		if (!platform.isJvm()) return
		container.useInstance(this)
	}
	
	override fun check(
		declaration: KtDeclaration,
		descriptor: DeclarationDescriptor,
		context: DeclarationCheckerContext
	) {
		when (descriptor) {
			is ClassDescriptor -> {
				val trace = context.trace
				val element = descriptor.findPsi()
				if (element is KtClass) {
					val classDescriptor =
						trace.bindingContext.get(
							BindingContext.CLASS,
							element
						) ?: error("Element class context not found")
					val composableAnnotationEntry = element.annotationEntries.singleOrNull {
						trace.bindingContext.get(
							BindingContext.ANNOTATION,
							it
						)?.isComposableAnnotation ?: false
					}
					if (composableAnnotationEntry != null &&
						!ComposeUtils.isComposeComponent(classDescriptor)) {
						trace.report(
							Errors.WRONG_ANNOTATION_TARGET.on(
								composableAnnotationEntry,
								"class which does not extend androidx.compose.Component"
							)
						)
					}
				}
			}
			is PropertyDescriptor -> {}
			is LocalVariableDescriptor -> {}
			is TypeAliasDescriptor -> {}
			is FunctionDescriptor -> analyze(context.trace, descriptor)
			else ->
				throw Error("currently unsupported " + descriptor.javaClass)
		}
	}
	
	override fun check(
		resolvedCall: ResolvedCall<*>,
		reportOn: PsiElement,
		context: CallCheckerContext
	) {
		val shouldBeTag = shouldInvokeAsTag(context.trace, resolvedCall)
		context.trace.record(
			FCS_RESOLVEDCALL_COMPOSABLE,
			resolvedCall.call.callElement,
			shouldBeTag
		)
	}
	
	override fun checkType(
		expression: KtExpression,
		expressionType: KotlinType,
		expressionTypeWithSmartCast: KotlinType,
		c: ResolutionContext<*>
	) {
		if (expression is KtLambdaExpression) {
			val expectedType = c.expectedType
			if (expectedType === TypeUtils.NO_EXPECTED_TYPE) return
			val expectedComposable = expectedType.hasComposableAnnotation()
			val composability = analyze(c.trace, expression, c.expectedType)
			if ((expectedComposable && composability == Widgetability.notWidget) ||
				(!expectedComposable && composability == Widgetability.marked)) {
				val isInlineable =
					isInlinedArgument(
						expression.functionLiteral,
						c.trace.bindingContext,
						true
					)
				if (isInlineable) return
				
				if (expression.parent is KtLambdaArgument) {
					val callDescriptor = expression
						.parent
						?.parent
						?.cast<KtCallExpression>()
						?.getResolvedCall(c.trace.bindingContext)
						?.candidateDescriptor
					
					if (callDescriptor is ComposableEmitDescriptor) {
						return
					}
				}
				
				val reportOn =
					if (expression.parent is KtAnnotatedExpression)
						expression.parent as KtExpression
					else expression
				c.trace.report(
					Errors.TYPE_MISMATCH.on(
						reportOn,
						expectedType,
						expressionTypeWithSmartCast
					)
				)
			}
			return
		} else {
			val expectedType = c.expectedType
			
			if (expectedType === TypeUtils.NO_EXPECTED_TYPE) return
			if (expectedType === TypeUtils.UNIT_EXPECTED_TYPE) return
			
			val nullableAnyType = expectedType.builtIns.nullableAnyType
			val anyType = expectedType.builtIns.anyType
			
			if (anyType == expectedType.lowerIfFlexible() &&
				nullableAnyType == expectedType.upperIfFlexible()) return
			
			val nullableNothingType = expectedType.builtIns.nullableNothingType
			
			// Handle assigning null to a nullable composable type
			if (expectedType.isMarkedNullable &&
				expressionTypeWithSmartCast == nullableNothingType) return
			
			val expectedComposable = expectedType.hasComposableAnnotation()
			val isComposable = expressionType.hasComposableAnnotation()
			
			if (expectedComposable != isComposable) {
				val reportOn =
					if (expression.parent is KtAnnotatedExpression)
						expression.parent as KtExpression
					else expression
				c.trace.report(
					Errors.TYPE_MISMATCH.on(
						reportOn,
						expectedType,
						expressionTypeWithSmartCast
					)
				)
			}
			return
		}
	}
	
	override fun checkEntries(
		entries: List<KtAnnotationEntry>,
		actualTargets: List<KotlinTarget>,
		trace: BindingTrace
	) {
		val entry = entries.singleOrNull {
			trace.bindingContext.get(BindingContext.ANNOTATION, it)?.isComposableAnnotation ?: false
		}
		if ((entry?.parent as? KtAnnotatedExpression)?.baseExpression is
				KtObjectLiteralExpression) {
			trace.report(
				Errors.WRONG_ANNOTATION_TARGET.on(
					entry,
					"class which does not extend androidx.compose.Component"
				)
			)
		}
	}
	
	operator fun Widgetability.plus(rhs: Widgetability): Widgetability =
		if (this > rhs) this else rhs
}
