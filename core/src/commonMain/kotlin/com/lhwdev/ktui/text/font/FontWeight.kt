package com.lhwdev.ktui.text.font

import com.lhwdev.ktui.Immutable
import com.lhwdev.ktui.utils.lerp


@Immutable
data class FontWeight(internal val weight: Int) : Comparable<FontWeight> {
	companion object {
		/** Thin, the minimum thickness */
		val w100 = FontWeight(100)
		
		/** Extra-light */
		val w200 = FontWeight(200)
		
		/** Light */
		val w300 = FontWeight(300)
		
		/** Normal / regular / plain */
		val w400 = FontWeight(400)
		
		/** Medium */
		val w500 = FontWeight(500)
		
		/** Semi-bold */
		val w600 = FontWeight(600)
		
		/** Bold */
		val w700 = FontWeight(700)
		
		/** Extra-bold */
		val w800 = FontWeight(800)
		
		/** Black, maximum thickness */
		val w900 = FontWeight(900)
		
		/** The default font weight. */
		val normal = w400
		
		/** A commonly used font weight that is heavier than normal. */
		val bold = w700
		
		/** An array of all the font weights. */
		internal val values: Array<FontWeight> = arrayOf(
			w100,
			w200,
			w300,
			w400,
			w500,
			w600,
			w700,
			w800,
			w900
		)
	}
	
	internal val index: Int get() = weight / 100 - 1
	
	override fun compareTo(other: FontWeight): Int {
		return weight.compareTo(other.weight)
	}
	
	override fun toString(): String {
		return when(index) {
			0 -> "FontWeight.w100"
			1 -> "FontWeight.w200"
			2 -> "FontWeight.w300"
			3 -> "FontWeight.w400"
			4 -> "FontWeight.w500"
			5 -> "FontWeight.w600"
			6 -> "FontWeight.w700"
			7 -> "FontWeight.w800"
			8 -> "FontWeight.w900"
			else -> "FontWeight Unknown"
		}
	}
}

/**
 * Linearly interpolate between two font weights
 *
 * Rather than using fractional weights, the interpolation rounds to the
 * nearest weight.
 *
 * The [fraction] argument represents position on the timeline, with 0.0 meaning
 * that the interpolation has not started, returning [start] (or something
 * equivalent to [start]), 1.0 meaning that the interpolation has finished,
 * returning [stop] (or something equivalent to [stop]), and values in between
 * meaning that the interpolation is at the relevant point on the timeline
 * between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and
 * 1.0, so negative values and values greater than 1.0 are valid (and can
 * easily be generated by curves).
 */
fun lerp(start: FontWeight?, stop: FontWeight?, fraction: Float): FontWeight {
	val index = lerp(
		start?.index ?: FontWeight.normal.index,
		stop?.index ?: FontWeight.normal.index,
		fraction
	).coerceIn(0, FontWeight.values.size - 1)
	return FontWeight.values[index]
}
